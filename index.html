<!DOCTYPE html>
<html>
  <body>
    <div id="root"></div>
  </body>
  <script
    crossorigin
    src="https://unpkg.com/react@18/umd/react.development.js"
  ></script>
  <script
    crossorigin
    src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
  ></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/prop-types@15.7.2/prop-types.js"></script>
  <script type="text/babel">
    function Ex(props) {
      console.log(props);
      // 콘솔 결과 : object { banana="hello" tomato="world" }
      // object는 컴포넌트의 첫 번째 인자로 주어지는 데, 이때 두 번째 인자는 없음 → object에 다 담겨서 옴
      // 받아온 object를 사용하려면 props.banana 이런 식으로 작성해야됨
      // props가 첫 번째 인자이자 전달받는 유일한 인자임.
      // 사람들은 props로 받는 방식을 잘 안씀
      return <div></div>;
    }

    function Btn({ banana, fontSize = 12, changeValue }) {
      // fontSize = 12 : 정의되지 않은 값에 대한 기본 값을 줌 → 여기서 Continue 버튼은 fontSize가 12가 됨
      return (
        <button
          onClick={changeValue}
          style={{
            backgroundColor: "tomato",
            color: "white",
            padding: "10px 20px",
            border: 0,
            borderRadius: 10,
            fontSize, // → fontSize = fontSize 랑 같음
          }}
        >
          {banana}
        </button>
      );
    }

    const MemorizedBtn = React.memo(Btn);
    // memo를 통해 props가 변경되지 않는 컴포넌트는 리렌더링이 되지 않도록 할 수 있음  → 왜냐하면 리렌더링이 실행되면 동일 컴포넌트에 있는 모든 것들이 리렌더링되기 때문에 props 변화가 없는 거까지 (여기서는 Continue Btn) 리렌더링이 됨 → 딱히 중요하진 않고 그냥 있다는 걸 알려주는 거
    // ⇒ 근데 만약 컴포넌트 리렌더링 때문에 너무 느려진다면 이게 해결방안일 수가 있음

    // string을 넣어야 하는 prop에 숫자를 잘못 넣는다는 등의 실수는 React가 잘못됐는 지 모르므로 이를 우리가 알기 위해 PropType 사용 → PropType은 우리가 어떤 타입의 prop을 받고 있는 지를 체크해줌
    Btn.propTypes = {
      // .propTypes = {} 내에 우리가 props 타입이 뭐고 어떤 모양이어야 하는 지를 설명해줄 수 있음
      banana: PropTypes.string.isRequired,
      // .isRequired은 필수로 들어가야하는 거라고 지정해주는 건데 없으면 PropType가 에러를 발생시킴
      fontSize: PropTypes.number,
    };

    function App() {
      const [value, setValue] = React.useState("Save Changes");
      const changeValue = () => setValue("Revert Changes");
      return (
        <div>
          <Ex banana="hello" tomato="world" />
          <MemorizedBtn
            banana={value}
            fontSize={18}
            changeValue={changeValue}
          />
          <MemorizedBtn banana="Continue" />
        </div>
        // props는 일종의 방식, 부모 컴포넌트로부터 자식 컴포넌트에 데이터를 보낼 수 있게 해주는 방법
        // React JS는 자동으로 이곳에서 넣은 모든 property(prop)들을 모조리 object 안으로 넣음

        // <Btn banana="Save Changes" /> ⇒ Btn({banana="Save Changes"}) 이런 느낌이라고 생각하면 됨

        // <Btn banana="Save Changes" onClick={onClick} />
        // Btn 뒤에 onClick을 넣는다면 그건 이벤트 리스너가 아니라 단순 하나의 prop일 뿐임(이름만 똑같이 씀)
        // ★★★ Btn 뒤에 무엇을 넣든 전부 단순한 prop일 뿐!!

        // 버튼을 클릭했을 때 changeValue가 실행되고 setValue()로 인해 값이 바뀌면서 !! 버튼을 클릭했을 때마다 리렌더링됨 !!
      );
    }
    const root = document.getElementById("root");
    ReactDOM.createRoot(root).render(<App />);
  </script>
</html>
